<!doctype html><html lang=zh-Hans><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>柳上川</title><meta content=柳上川的博客 name=description><link href=/styles/tailwind.css rel=stylesheet><body><link rel="shortcut icon" href=/images/blog/avatar.avif type=image/x-icon><link href=/styles/highlight.min.css rel=stylesheet><link href=/fonts/MapleMono-NF-CN-Regular/result.css rel=stylesheet><link href=/fonts/MapleMono-NF-CN-Italic/result.css rel=stylesheet><link href=/fonts/MapleMono-NF-CN-Bold/result.css rel=stylesheet><script src=/scripts/highlight.min.js></script><script src=/scripts/rust.min.js></script><script src=/scripts/nix.min.js></script><script src=/scripts/scheme.min.js></script><script>hljs.highlightAll();
    document.addEventListener('DOMContentLoaded', function(event) {
      hljs.highlightAll();
    });
    window.addEventListener('pageshow', function(event) {
      // 如果页面是从 bfcache (Back-Forward Cache) 中恢复的
      if (event.persisted) {
        hljs.highlightAll();
      }
    });
    document.addEventListener('htmx:afterSwap', function(event) {
      hljs.highlightAll();
    });</script><script defer src=/scripts/prefetch.js></script><script>if (!document.querySelector('meta[name="darkreader-lock"]')) {
      const lock = document.createElement('meta');
      lock.name = 'darkreader-lock';
      document.head.appendChild(lock);
    }</script><link href=/styles/catppuccin-macchiato.css rel=stylesheet><script src=/scripts/htmx.min.js></script><link href=/styles/tailwind.css rel=stylesheet><link href=/iconfonts/iconfont.css rel=stylesheet><div class="flex flex-col mx-4 mb-20 scroll-smooth" id=content lang=zh-Hans><div class="text-2xl sm:text-3xl my-4 w-full text-center">『clap-rs 简介』</div><div class="font-medium w-fit sm:mx-auto flex flex-col border-l-4 pl-2 sm:flex-row sm:border-l-0 sm:pl-0"><p>写自:2022-08-16<div class="px-2 hidden sm:inline">│</div><p>作者:柳上川</div><div class="flex flex-col items-center m-4"><div class="w-fit mx-auto text-lg font-semibold">摘要</div><div class="w-fit break-keep text-center sm:mx-[25%] *:inline">了解命令行, 然后用 clap-rs 写个类似 GNU/wc 的小命令吧, 增加了进度条, 表格输出, 并行化等功能</div></div><div class="flex flex-col my-10 w-fit border-2 border-slate-500"><p><span class=text-2xl>目录:</span><div class="w-fit pr-2 my-2"><div class=leading-5><span class=pl-2><span class="font-bold text-sm">┌─►</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#cheng-pin-zhan-shi>成品展示</a></span></div><div class=leading-5><span class=pl-2><span class="font-bold text-sm">├─►</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#ji-chu-gai-nian>基础概念</a></span></div><div class=leading-5><span class=pl-2><span class="font-bold text-sm">├─►</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#chu-shi-pei-zhi>初始配置</a></span></div><div class=leading-5><span class=pl-2><span class="font-bold text-sm">├─►</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#ming-ling-ding-yi>命令定义</a></span></div><div class=leading-5><span class=pl-2><span class="font-bold text-sm">├───</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#bang-zhu-xin-xi>帮助信息</a></span></div><div class=leading-5><span class=pl-2><span class="font-bold text-sm">├───</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#xuan-xiang-yu-can-shu>选项与参数</a></span></div><div class=leading-5><span class=pl-2><span class="font-bold text-sm">├───</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#can-shu-jie-xi-qi>参数解析器</a></span></div><div class=leading-5><span class=pl-2><span class="font-bold text-sm">├───</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#can-shu-guan-xi>参数关系</a></span></div><div class=leading-5><span class=pl-2><span class="font-bold text-sm">├───</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#zi-ming-ling>子命令</a></span></div><div class=leading-5><span class=pl-2><span class="font-bold text-sm">├─►</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#luo-ji-shi-xian>逻辑实现</a></span></div><div class=leading-5><span class=pl-2><span class="font-bold text-sm">└─►</span><a class="text-sm hover:text-sky-500 hover:font-semibold hover:underline underline-offset-5" href=#zi-dong-bu-quan>自动补全</a></span></div></div></div><p>前置知识: rust 语法基础<br>完整代码: <a class="underline underline-offset-5 font-medium" href=https://github.com/Jedsek/rust-wc>rust-wc</a><br><br><em>注意</em>:<br>本项目基于当前最新版本的 clap, 也就是 version 4 本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)<br>推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手<br><br>官方教程: <a class="underline underline-offset-5 font-medium" href=https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html>derive-tutorial</a><br>官方资料: <a class="underline underline-offset-5 font-medium" href=https://docs.rs/clap/latest/clap/_derive/index.html>derive-reference</a><br><hr class="border-2 border-dashed my-10"><h1 class="flex items-center w-fit my-6" id=cheng-pin-zhan-shi><span class="text-2xl mr-2 text-cyan-500">🔗</span> <a class="text-4xl hover:underline underline-offset-8" href=#cheng-pin-zhan-shi>成品展示</a></h1><ul class="list-disc ml-5"><li>通过如下命令从 crates.io 上下载成品, 可执行文件的名称是 rwc:</ul><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-text text-sm sm:text-base">cargo install rust-wc</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>以下是使用 asciinema 录制的展示:<br></p><script async id=asciicast-534647 src=https://asciinema.org/a/534647.js></script><hr class="border-2 border-dashed my-10"><h1 class="flex items-center w-fit my-6" id=ji-chu-gai-nian><span class="text-2xl mr-2 text-cyan-500">🔗</span> <a class="text-4xl hover:underline underline-offset-8" href=#ji-chu-gai-nian>基础概念</a></h1><p>CLI, 是 <em>Command Line Interface</em> 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理<br>如在Linux下常见的 ls/cp/mv 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出<br><br>GNU 项目提供了非常多的开源命令, 如 wc, 它可以统计文件的 bytes/char/line 的数量<br>我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 wc<br><br><em>注意</em>:<br>cli 可以代表抽象的界面, 也可以指代具体的某个程序<br>后文中的 cli , 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等<br><br>再写之前, 我们还应了解些基本概念 (直接跳过感觉也木得问题??):<br><br><ul class="list-disc ml-5"><li>参数(arguments):<br></ul><p>传给命令的参数, 比如一个路径<br><br><ul class="list-disc ml-5"><li>选项(options):<br></ul><p>通常以单/双横杠开头, 不同的 options 表示不同的行为<br>比如 <code class="font-semibold text-[#aa8bd5]"><code>ls ./*</code></code>, 表示以默认行为下进行输出, <code class="font-semibold text-[#aa8bd5]"><code>ls -l ./*</code></code> 以长列表形式输出, <code class="font-semibold text-[#aa8bd5]"><code>ls -a ./*</code></code> 输出所有隐藏文件<br>单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 <code class="font-semibold text-[#aa8bd5]"><code>ls -i</code></code> 与 <code class="font-semibold text-[#aa8bd5]"><code>ls --inode</code></code><br><br><ul class="list-disc ml-5"><li>子命令(subcommands):<br></ul><p>一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options<br>比如 <code class="font-semibold text-[#aa8bd5]"><code>cargo build</code></code> 与 <code class="font-semibold text-[#aa8bd5]"><code>cargo publish</code></code>, 都是 cargo 的子命令<br><br><ul class="list-disc ml-5"><li>双横杠(–):<br></ul><p>在命令后面的某处位置, 加上 <code class="font-semibold text-[#aa8bd5]"><code>--</code></code>, 可以将 <code class="font-semibold text-[#aa8bd5]"><code>--</code></code> 后面的内容当作 argument 传入, 而非 options<br>举个例子, 我有个文件, 叫做 <code class="font-semibold text-[#aa8bd5]"><code>--asd</code></code>, 我想使用 <code class="font-semibold text-[#aa8bd5]"><code>cat --asd</code></code> 来输出里面的内容<br>如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 <code class="font-semibold text-[#aa8bd5]"><code>cat</code></code> 本身没 <code class="font-semibold text-[#aa8bd5]"><code>--asd</code></code> 这个option, 故失败<br>在比如有个文件叫 <code class="font-semibold text-[#aa8bd5]"><code>--help</code></code>, 使用 <code class="font-semibold text-[#aa8bd5]"><code>cat --help</code></code> 将会打印其 help 信息<br>此时, 你应该使用 <code class="font-semibold text-[#aa8bd5]"><code>cat -- --asd</code></code>, 将 <code class="font-semibold text-[#aa8bd5]"><code>--asd</code></code> 视作参数传入<br><br><ul class="list-disc ml-5"><li>短/长帮助(short/long help):<br></ul><p>有些命令, <code class="font-semibold text-[#aa8bd5]"><code>-h</code></code> 与 <code class="font-semibold text-[#aa8bd5]"><code>--help</code></code> 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息<br><hr class="border-2 border-dashed my-10"><h1 class="flex items-center w-fit my-6" id=chu-shi-pei-zhi><span class="text-2xl mr-2 text-cyan-500">🔗</span> <a class="text-4xl hover:underline underline-offset-8" href=#chu-shi-pei-zhi>初始配置</a></h1><p>以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件, 请自行创建好目录:<pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-text text-sm sm:text-base">./rust-wc
├── Cargo.lock
├── Cargo.toml
└── src
   ├── wc_result.rs   # 计算并存储结果
   ├── cli.rs         # 命令行的定义
   ├── files.rs       # 读取文件
   ├── lib.rs         # 声明模块, 类型别名
   └── main.rs</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>让我们新建一个叫做 rust-wc 的项目:<pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-toml text-sm sm:text-base"># Cargo.toml
# 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)
[package]
name = "rust-wc"
authors = ["jedsek &lt;jedsek@qq.com>"]
version = "0.0.1"
description = "A GNU/wc implementation written in rust, which is faster when reading a large of big files"
edition = "2021"

# 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`
[[bin]]
name = "rwc"
path = "src/main.rs"

# 指定依赖
[dependencies]
clap = {version = "4.0.29", features = ["derive"]}     # 解析参数
unicode-width = "0.1.10"                               # 计算 Unicode 字符宽度
indicatif = "0.17.2"                                   # 进度条
prettytable-rs = "0.9.0"                               # 打印表格
rayon = "1.6.1"                                        # 并行化</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">// src/lib.rs
use std::{collections::HashMap, path::PathBuf};

pub mod cli;
pub mod files;
pub mod wc_result;

pub type Result&lt;T> = std::result::Result&lt;T, Box&lt;dyn std::error::Error>>;
pub type Counts = Vec&lt;usize>;
pub type PathWithContent = HashMap&lt;PathBuf, String>;</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><hr class="border-2 border-dashed my-10"><h1 class="flex items-center w-fit my-6" id=ming-ling-ding-yi><span class="text-2xl mr-2 text-cyan-500">🔗</span> <a class="text-4xl hover:underline underline-offset-8" href=#ming-ling-ding-yi>命令定义</a></h1><p><em>注意</em>:<br>clap-v3 时, 融进了另一个很强大的命令行编写库: structopt<br>因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap<br>这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码<br><br>让我们来想象下这个命令:<br><ul class="list-disc ml-5"><li>必须接受一个参数<li>参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容<li>根据启用的 flag 来决定计算并打印哪些东西</ul><p><br>多亏了 derive 宏, 我们可以这样定义它, 下面是 <code class="font-semibold text-[#aa8bd5]"><code>src/cli.rs</code></code> 的完整代码:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">// src/cli.rs
use clap::{ArgGroup, Parser, Subcommand};
use std::path::PathBuf;

#[derive(Parser)]  // 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 
#[command(
    author, version, about, subcommand_negates_reqs = true,
    group(
        ArgGroup::new("options")
            .multiple(true)
            .required(true)
            .args(&[ "bytes", "chars", "words", "lines", "longest_line"])
    ),
)]
pub struct Cli {
    /// The path(s) you should provide
    #[arg(value_parser = check_path, value_name = "PATH", required = true)]
    pub paths: Vec&lt;PathBuf>,

    /// Print the byte counts
    #[arg(short, long)]
    pub bytes: bool,

    /// Print the character counts
    #[arg(short, long)]
    pub chars: bool,

    /// Print the word counts
    #[arg(short, long)]
    pub words: bool,

    /// Print the line counts
    #[arg(short, long)]
    pub lines: bool,

    /// Print the maximum line width (Unicode)
    #[arg(short = 'L', long)]
    pub longest_line: bool,

    #[command(subcommand)]
    pub sub_commands: Option&lt;SubCommands>,
}

#[derive(Subcommand)]
pub enum SubCommands {
    /// Enabled all available options
    All {
        /// The path(s) you should provide
        #[arg(value_parser = check_path, value_name = "PATH", required = true)]
        paths: Vec&lt;PathBuf>,
    },
}


// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容
fn check_path(filename: &str) -> Result&lt;PathBuf, String> {
    let path = PathBuf::from(filename);
    if filename == "-" || path.exists() {
        Ok(path)
    } else {
        Err(format!("No such path: `{}`", path.display()))
    }
}

impl Cli {
    // 开启所有的 options
    pub fn enable_all_options(&mut self) {
        self.bytes = true;
        self.chars = true;
        self.words = true;
        self.lines = true;
        self.longest_line = true;
    }
        
    // 返回启用的options, 类型是 Vec&lt;&str>, 方便后面打印表格时, 作为表格的标题
    pub fn get_enabled_options(&self) -> Vec&lt;&'static str> {
        let mut enabled_options = vec![];

        self.bytes.then(|| enabled_options.push("Bytes"));
        self.chars.then(|| enabled_options.push("Chars"));
        self.words.then(|| enabled_options.push("Words"));
        self.lines.then(|| enabled_options.push("Lines"));
        self.longest_line.then(|| enabled_options.push("Maximum line width (Unicode)"));

        enabled_options
    }
}</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>以上的代码表示, 我们定义了一个 <code class="font-semibold text-[#aa8bd5]"><code>Cli</code></code> 结构体, 表示对输入参数的建模<br>得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型<br>也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示<br><br>clap 已经为我们做好了一切 :)<br>我们能调用 clap 为我们实现的 trait <code class="font-semibold text-[#aa8bd5]"><code>Parser</code></code> 中的 <code class="font-semibold text-[#aa8bd5]"><code>parse</code></code> 方法, 解析参数并进行转换:<br><h2 class="flex items-center w-fit my-6" id=bang-zhu-xin-xi><span class="text-2xl m-2 text-cyan-500">> </span> <a class="text-2xl hover:underline underline-offset-8" href=#bang-zhu-xin-xi>帮助信息</a></h2><p>现在先让我们运行 <code class="font-semibold text-[#aa8bd5]"><code>cargo run -- -h</code></code> 看看效果, 查看下 help 吧:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-text text-sm sm:text-base">A GNU/wc clone written in rust, which is super faster when reading a large of big files

Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-line> &lt;PATH>...
       rwc [PATH]... &lt;COMMAND>

Commands:
  all   Enabled all available options
  help  Print this message or the help of the given subcommand(s)

Arguments:
  &lt;PATH>...  The path(s) you should provide

Options:
  -b, --bytes         Print the byte counts
  -c, --chars         Print the character counts
  -w, --words         Print the word counts
  -l, --lines         Print the line counts
  -L, --longest-line  Print the maximum line width (Unicode)
  -h, --help          Print help information
  -V, --version       Print version information</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>哇哦! 若你用这段文字, 对比下前面的 src/cli.rs, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息<br>没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息<br><br>如果你不想要 about 信息直接照搬 Cargo.toml 里的 description 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">#[derive(Parser)]
#[command(
    about = "...",
// ......
// ......</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>并且, 像 author/version/about 等信息, 是通过读取 Cargo.toml 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁<br>你可以查看 <a class="underline underline-offset-5 font-medium" href=https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template>help_template</a> 知晓如何显示, 例子可能是 builder形式, 也就是非声明式, 但别慌张:<br><br>你可以像这样将 builder形式 的代码转化为 derive形式<br>实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">Command::new("myprog")
    .help_template("{bin} ({version}) - {usage}")

#[derive(Parser)]
#[command(
    help_template = "{bin} ({version}) - {usage}",
// ......
// ......</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><h2 class="flex items-center w-fit my-6" id=xuan-xiang-yu-can-shu><span class="text-2xl m-2 text-cyan-500">> </span> <a class="text-2xl hover:underline underline-offset-8" href=#xuan-xiang-yu-can-shu>选项与参数</a></h2><p>clap 能非常方便地以声明的方式, 定义选项/参数<br>对于一个option, 比如 <code class="font-semibold text-[#aa8bd5]"><code>-b/--bytes</code></code>, 你只需要这样写:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">/// Print the byte counts
#[arg(short, long)]
pub bytes: bool,</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>它由三部分组成:<ul class="list-disc ml-5"><li>文档注释: help 中对该命令的解释<li>arg(short, long): 该 option 具有短/长横杠的形式<li>类型为bool: 传入时默认的行为是将其设置为 true</ul><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-text text-sm sm:text-base">Options:
  -b, --bytes         Print the byte counts</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>当你传入该参数时, Cli 实例中的 bytes 属性将被设置为 true<br>你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部<br><br>比如 <code class="font-semibold text-[#aa8bd5]"><code>-l/--lines</code></code> 与 <code class="font-semibold text-[#aa8bd5]"><code>-L/--longest-line</code></code>, 不指定时都是 -l, 编译会报错, 需要自己指定:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">/// Print the maximum line width (Unicode)
#[arg(short = 'L', long)]
pub longest_line: bool,</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>当你没有添加 short 或 long 时, 自然就代表这是个 argument<br>在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 <code class="font-semibold text-[#aa8bd5]"><code>Vec&lt;PathBuf></code></code> 来表示它, clap 会自动将参数解析为路径<br>为了醒目, 我们将其显示在 help 中的名字, 改为大写的 <code class="font-semibold text-[#aa8bd5]"><code>PATH</code></code>, 同时指定该参数必选, 防止路径数为0:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">/// The path(s) you should provide
#[arg(value_name = "PATH", required = true)]
pub paths: Vec&lt;PathBuf>,</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你<br>当我们输入 <code class="font-semibold text-[#aa8bd5]"><code>cargo run -- -b</code></code>:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-text text-sm sm:text-base">error: The following required arguments were not provided:
  &lt;PATH>...

Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-line> &lt;PATH>...

For more information try '--help'</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>但此时, 其实还有一个问题: 参数虽然被转化为 <code class="font-semibold text-[#aa8bd5]"><code>PathBuf</code></code>, 但不存在的路径也是路径啊! 此时就应该报错才行<br>没错, clap 只是负责帮我们生成 进行转换的代码<br>但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 :)<br><br>因此, 我们来学学如何使用自定义的参数解析器吧<br><h2 class="flex items-center w-fit my-6" id=can-shu-jie-xi-qi><span class="text-2xl m-2 text-cyan-500">> </span> <a class="text-2xl hover:underline underline-offset-8" href=#can-shu-jie-xi-qi>参数解析器</a></h2><p>有些疑问或许会萦绕在你的心头:<br><ul class="list-disc ml-5"><li>clap 是怎么进行解析的?<li>clap 能否将传入的参数, 解析为自定义的类型呢?<li>我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?</ul><p><br>实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证<br>比如, 如果我们想验证传入的路径是否合法, 可以这样写:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">// ......
// ......
    /// The path(s) you should provide
    #[arg(value_parser = check_path, value_name = "PATH", required = true)]
    pub paths: Vec&lt;PathBuf>,
// ......
// ......

fn check_path(filename: &str) -> Result&lt;PathBuf, String> {
    let path = PathBuf::from(filename);
    if filename == "-" || path.exists() {
        Ok(path)
    } else {
        Err(format!("No such path: `{}`", path.display()))
    }
}</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>good, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误<br>该错误会在用户传入非法路径时, 作为报错信息出现<br>当我们输入 <code class="font-semibold text-[#aa8bd5]"><code>cargo run -- -b asdxxx</code></code>:<pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-text text-sm sm:text-base">error: Invalid value "asd" for '&lt;PATH>...': No such path: `asdxxx`

For more information try '--help'</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser<br>得益于此, 你可以为任何类型定义对应的 parser<br><h2 class="flex items-center w-fit my-6" id=can-shu-guan-xi><span class="text-2xl m-2 text-cyan-500">> </span> <a class="text-2xl hover:underline underline-offset-8" href=#can-shu-guan-xi>参数关系</a></h2><p>有时候, 我们可能会面临这样或那样的问题:<br><ul class="list-disc ml-5"><li>当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用<li>一个或多个指定的 option(s) 必须被启用<li>多个指定的 options 可以同时被启用</ul><p>如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情<br>它叫做 <em>参数关系(Argument Relations)</em>, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改<br>因此, 我们可以使用 <em>Arg/ArgGroup (参数与参数组)</em> 来声明这些关系<br><br>实际上, 你先前在 <code class="font-semibold text-[#aa8bd5]"><code>paths</code></code> 头上写的 <code class="font-semibold text-[#aa8bd5]"><code>required = true</code></code>, 就是一种参数关系<br><br>以我们的 rwc 举个例子:<br><ul class="list-disc ml-5"><li><code class="font-semibold text-[#aa8bd5]"><code>-b/-c/-w/-l/-L</code></code> 能同时出现, 即支持类似 <code class="font-semibold text-[#aa8bd5]"><code>-b -c -w 或 -bcw</code></code> 的形式<li><code class="font-semibold text-[#aa8bd5]"><code>-b/-c/-w/-l/-L</code></code> 至少出现其中一个, 防止只传路径不传 option</ul><p><br>任何一个 <code class="font-semibold text-[#aa8bd5]"><code>Arg</code></code> 类型 (被 <code class="font-semibold text-[#aa8bd5]"><code>#[arg]</code></code> 所修饰的), 或者 <code class="font-semibold text-[#aa8bd5]"><code>ArgGroup</code></code>, 都能够声明这种参数间的关系<br>我们可以新建一个 <code class="font-semibold text-[#aa8bd5]"><code>ArgGroup</code></code> 的实例, 然后把先前的一坨 <code class="font-semibold text-[#aa8bd5]"><code>-b/-c/-w/-l/-L</code></code> 都放入其中:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">// ......
// ......
#[derive(Parser)]
#[command(
    author, version, about, subcommand_negates_reqs = true,
    group(
        ArgGroup::new("options")
            .multiple(true)
            .required(true)
            .args(&[ "bytes", "chars", "words", "lines", "longest_line"])
    ),
)]
pub struct Cli {
    /// The path(s) you should provide
    #[arg(value_parser = check_path, value_name = "PATH", required = true)]
    pub paths: Vec&lt;PathBuf>,
// ......
// ......</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p><code class="font-semibold text-[#aa8bd5]"><code>multiple(true)</code></code> 表示可以同时出现参数组的成员, <code class="font-semibold text-[#aa8bd5]"><code>required(true)</code></code> 表示至少传入该参数组中的其中一个成员<br><h2 class="flex items-center w-fit my-6" id=zi-ming-ling><span class="text-2xl m-2 text-cyan-500">> </span> <a class="text-2xl hover:underline underline-offset-8" href=#zi-ming-ling>子命令</a></h2><p>我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">pub struct Cli {
// ......
// ......
    #[command(subcommand)]
    pub sub_commands: Option&lt;SubCommands>,
}

#[derive(Subcommand)]
pub enum SubCommands {
    /// Enabled all available options
    All {
        /// The path(s) you should provide
        #[arg(value_parser = check_path, value_name = "PATH", required = true)]
        paths: Vec&lt;PathBuf>,
    },
}</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>你可以会想, 能不能让子命令复用 <code class="font-semibold text-[#aa8bd5]"><code>Cli</code></code> 中定义的 <code class="font-semibold text-[#aa8bd5]"><code>paths</code></code>, 减少重复代码呢?<br>当然可以, 请在其成员 <code class="font-semibold text-[#aa8bd5]"><code>paths</code></code> 头上的 <code class="font-semibold text-[#aa8bd5]"><code>#[arg]</code></code> 中, 添加 <code class="font-semibold text-[#aa8bd5]"><code>global = true</code></code>, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数<br><br>但非常遗憾, 当设置 <code class="font-semibold text-[#aa8bd5]"><code>global = true</code></code> 后, 就无法设置 <code class="font-semibold text-[#aa8bd5]"><code>required = true</code></code> 了, 因此我们还是得定义一份相同的参数, 详见相关的 <a class="underline underline-offset-5 font-medium" href=https://github.com/clap-rs/clap/issues/1546>issue</a><br><br><em>注意</em>:<br>这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入<br>但本文还是定义了 subcommand 以便读者了解, 起演示作用<br><hr class="border-2 border-dashed my-10"><h1 class="flex items-center w-fit my-6" id=luo-ji-shi-xian><span class="text-2xl mr-2 text-cyan-500">🔗</span> <a class="text-4xl hover:underline underline-offset-8" href=#luo-ji-shi-xian>逻辑实现</a></h1><p>根据:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-text text-sm sm:text-base">   ├── wc_result.rs   # 计算并存储结果
   ├── cli.rs         # 命令行的定义
   ├── files.rs       # 读取文件</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了<br>为了避免你回到前面看 lib.rs 的内容, 下面再贴一遍:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">// src/lib.rs
use std::{collections::HashMap, path::PathBuf};

pub mod cli;
pub mod files;
pub mod wc_result;

pub type Result&lt;T> = std::result::Result&lt;T, Box&lt;dyn std::error::Error>>;
pub type Counts = Vec&lt;usize>;
pub type PathWithContent = HashMap&lt;PathBuf, String>;</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">// src/files.rs
// 声明依赖
// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好
use crate::{PathWithContent, Result};
use indicatif::{MultiProgress, ProgressBar, ProgressStyle};
use rayon::prelude::*;
use std::ffi::OsStr;
use std::process;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::{
    fs::File,
    io::{BufReader, Read},
    path::PathBuf,
};


// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果
// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)
static INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(0);
const BUFFER_SIZR: usize = 16 * 1024;


// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀
// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下
// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰
trait PathExt {
    fn without_dotted_prefix(&self) -> bool;
    fn add_dotted_prefix(&mut self);
}

impl PathExt for PathBuf {
    fn without_dotted_prefix(&self) -> bool {
        self.is_relative() && !self.starts_with("../") && !self.starts_with("./")
    }

    fn add_dotted_prefix(&mut self) {
        *self = PathBuf::from_iter([OsStr::new("./"), self.as_os_str()]);
    }
}

// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组
pub fn read_files(paths: Vec&lt;PathBuf>) -> Result&lt;PathWithContent> {
    println!("Reading files / Getting content from stdin:");

    // 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧
    let result = paths
        .into_par_iter()
        .filter(|path| path.is_file() || path.as_os_str() == "-")
        .map(|mut path| {
            let should_read_from_input = path.as_os_str() == "-";

            let content = get_content(&path, should_read_from_input);

            if path.without_dotted_prefix() {
                path.add_dotted_prefix();
            }

            if should_read_from_input {
                let inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(1, Ordering::SeqCst);
                path = PathBuf::from(format!("Input/{}", inputted_file_number));
            }

            let content = content.unwrap_or_else(|err| {
                eprintln!("{}: {}", path.display(), err);
                process::exit(1);
            });

            (path, content)
        })
        .collect();
    Ok(result)
}

// helper 函数, 针对单个路径
fn get_content(path: &PathBuf, should_read_from_input: bool) -> Result&lt;String> {
    if should_read_from_input {
        read_from_stdin()
    } else {
        let bars = MultiProgress::new();
        let style =
            ProgressStyle::with_template("[{elapsed}][{percent}%] {bar:45.cyan/blue} {bytes} {wide_msg}")?
                .progress_chars(">-");
        read_file_with_progress(path, style, bars)
    }
}

// 读取对应路径的文件
fn read_file_with_progress(path: &PathBuf, style: ProgressStyle, bars: MultiProgress) -> Result&lt;String> {
    let mut content = String::new();

    let file = File::open(path)?;
    let size = file.metadata()?.len();

    let bar = ProgressBar::new(size).with_message(format! {"Reading {}", path.display()}).with_style(style);
    let bar = bars.add(bar);

    let mut bufreader = BufReader::new(file);
    let mut buf = [0; BUFFER_SIZR];

    while let Ok(n) = bufreader.read(&mut buf) {
        if n == 0 {
            break;
        }
        bar.inc(n as u64);
        content += &String::from_utf8_lossy(&buf[..n]);
    }
    bar.finish_with_message("Done!");

    Ok(content)
}

// 从 stdin 中读取, 作为临时文件的内容
fn read_from_stdin() -> Result&lt;String> {
    let mut content = vec![];
    std::io::stdin().read_to_end(&mut content)?;
    Ok(String::from_utf8(content)?)
}</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">// src/wc_result.rs
// 声明依赖
use crate::{
    cli::{Cli, SubCommands},
    files::read_files,
    Counts, Result,
};
use prettytable::{cell, format::consts::FORMAT_BOX_CHARS, Row, Table};
use rayon::prelude::*;
use std::{collections::HashMap, path::PathBuf, str};

// 存放被启用的 options, 与键值对
pub struct WcResult {
    enabled_options: Vec&lt;&'static str>,
    paths_with_counts: HashMap&lt;PathBuf, Counts>,
}


// 实例化函数
pub fn get(mut cli: Cli) -> Result&lt;WcResult> {
    println!("Please waiting...\n");

    // 根据子命令进行相应操作
    match cli.sub_commands {
        Some(SubCommands::All { ref paths }) => {
            cli.paths = paths.clone();
            cli.enable_all_options();
        }
        None => cli.enable_all_options(),
    };

    // 进行计算
    println!("Calculating...");
    let wc_result = WcResult {
        enabled_options: cli.get_enabled_options(),
        paths_with_counts: {
            let contents = read_files(cli.paths.clone())?;
            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&cli, content))).collect()
        },
    };

    Ok(wc_result)
}

impl WcResult {
    // 将保存的信息转化为美化后的表格
    pub fn to_pretty_table(self) -> Table {
        let titles = {
            let enabled_options = self.enabled_options;
            let mut titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -> x)).collect());
            titles.insert_cell(0, cell!(Fybi -> "Path"));
            titles
        };

        let mut table = Table::new();
        table.set_titles(titles);
        table.set_format(*FORMAT_BOX_CHARS);

        for (path, counts) in self.paths_with_counts {
            let mut row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());
            let path_cell = if path.starts_with("Input") {
                cell!(Fbb -> path.display())
            } else {
                cell!(Fmb -> path.display())
            };

            row.insert_cell(0, path_cell);
            table.add_row(row);
        }

        table
    }
}

// 不太懂 rayon, 暂时这样糊上去了
fn calculate_counts(cli: &Cli, content: String) -> Counts {
    let v: Vec&lt;Option&lt;usize>> = vec![None; 5];
    v.into_par_iter()
        .enumerate()
        .map(|(idx, _)| match idx {
            0 => cli.bytes.then_some(content.len()),
            1 => cli.chars.then_some(content.chars().count()),
            2 => cli.words.then_some(content.split_whitespace().count()),
            3 => cli.lines.then_some(content.lines().count()),
            4 => cli
                .longest_line
                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(0)),
            _ => None,
        })
        .flatten()
        .collect()
}</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">// src/mian.rs
use clap::Parser;
use rust_wc::{cli::Cli, wc_result, Result};

fn main() -> Result&lt;()> {
    let cli = Cli::parse();
    let pretty_table = wc_result::get(cli)?.to_pretty_table();
    pretty_table.printstd();
    Ok(())
}</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><hr class="border-2 border-dashed my-10"><h1 class="flex items-center w-fit my-6" id=zi-dong-bu-quan><span class="text-2xl mr-2 text-cyan-500">🔗</span> <a class="text-4xl hover:underline underline-offset-8" href=#zi-dong-bu-quan>自动补全</a></h1><p>我们已经写好了命令行程序, 可以通过 <code class="font-semibold text-[#aa8bd5]"><code>-h/--help</code></code> 查看帮助信息, 但能不能更方便地与 shell 集成呢?<br>比如, 当你使用 bash/zsh/fish 时, 输入命令后点 Tab, 能帮你自动显示该命令的 flag/subcommand<br><br>我们将使用 clap_complete 这个库, 在编译器生成特定于 shell 的自动补全文件(也可以运行时生成, 看 <a class="underline underline-offset-5 font-medium" href=https://docs.rs/clap_complete/latest/clap_complete/>clap_complete</a> 的文档)<br>首先要修改 Cargo.toml, 在后面添加 build-dependencies:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-toml text-sm sm:text-base"># Cargo.toml
[build-dependencies]
clap = {version = "4.0.29", features = ["derive"]}
clap_complete = "4.0.6"</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-rust text-sm sm:text-base">// build.rs
use clap::CommandFactory;
use clap_complete::{generate_to, shells::*};
use std::error::Error;

include!("src/cli.rs");

fn main() -> Result&lt;(), Box&lt;dyn Error>> {
    let outdir = "completions";
    let app_name = "rwc";
    let mut cmd = Cli::command();

    generate_to(Bash, &mut cmd, app_name, outdir)?;
    generate_to(Zsh, &mut cmd, app_name, outdir)?;
    generate_to(Fish, &mut cmd, app_name, outdir)?;
    generate_to(Elvish, &mut cmd, app_name, outdir)?;
    generate_to(PowerShell, &mut cmd, app_name, outdir)?;

    Ok(())
}</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>目前, clap_complete 仅支持以上几种 shell, 更多的偏小众 shell, 一般以 clap_complete_xxx 的形式出现在 crates.io 上<br>比如 clap_complete_nushell, 但亲测质量不佳, 不建议使用<br><br>同时, 请确保项目根目录下存在 completions 目录, 随后运行 cargo build, 通过 tree 命令可以看到生成的补全文件:<br><pre class="group relative mx-2 sm:mx-6 my-4 border-2 border-slate-500 leading-[1.2em]"><script>function copy_code(button) {
          const code = button.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = '好啦';
            setTimeout(() => button.textContent = '复制', 2000);
          });
        }
        function fold_code(button) {
          const code = button.parentElement.querySelector('code');
          const next_fold_state = button.textContent
          if (next_fold_state == '折叠') {
            if (!code.hasAttribute('data-original')) {
              code.setAttribute('data-original', code.innerHTML)
            }
            const lines = code.innerHTML.split('\n')
            const firstLine = lines[0]
            code.innerHTML = firstLine
            // code.style.display = 'none'
            button.textContent = '展开'
          } else {
            const lines = code.getAttribute('data-original')
            // code.style.display = 'block'
            code.innerHTML = lines
            button.textContent = '折叠'
          }
        }</script><p><code class="language-text text-sm sm:text-base">completions
├── _rwc
├── rwc.bash
├── rwc.elv
├── rwc.fish
└── _rwc.ps1</code></p><button class="absolute top-2 right-2 hidden group-hover:inline text-xl" onclick=copy_code(this)>复制</button><button class="absolute top-2 right-16 hidden group-hover:inline text-xl" onclick=fold_code(this)>折叠</button></pre><p>就酱, 本文结束啦!<br>希望本文能帮到你, 让你快速了解使用 clap 的流程 :)<br></div>